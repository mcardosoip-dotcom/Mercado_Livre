import os
import re
import fitz  # PyMuPDF
import pdfplumber
import pandas as pd

# ====== Caminhos ======
pdf_path = r"G:\Drives compartilhados\Legales_Analytics\002 - Python\002-1 - DEV\Dev - CLM Ma e Mu\Matriz de arquivos\1dX1DC-vrs7w8rk_U2xUil3aPi8S_rNZF.pdf"
output_xlsx = r"G:\Drives compartilhados\Legales_Analytics\002 - Python\002-1 - DEV\Dev - CLM Ma e Mu\Resultado\Resultado.xlsx"

# ====== 1) Ler metadados ======
doc = fitz.open(pdf_path)
metadata = doc.metadata
page_count = doc.page_count
file_size_kb = round(doc.tobytes().__sizeof__() / 1024, 2)
doc.close()

# ====== 2) Extrair conte√∫do (pdfplumber) ======
pages_data = []
with pdfplumber.open(pdf_path) as pdf:
    for i, page in enumerate(pdf.pages, start=1):
        text = page.extract_text() or ""
        pages_data.append({"pagina": i, "conteudo": text.strip()})

df = pd.DataFrame([p for p in pages_data if p["conteudo"]])

# ====== 3) Regex de busca ======
# DocuSign (GUID separado para n√£o interferir no CPF)
GUID_RE = re.compile(r"\b[0-9A-Fa-f]{8}-(?:[0-9A-Fa-f]{4}-){3}[0-9A-Fa-f]{12}\b")
DOCUSIGN_RE = re.compile(r"DocuSign\s*Envelope\s*ID\s*[:\-‚Äì]?\s*([^\n]+)", flags=re.IGNORECASE)

# CPF / CNPJ / Multa ‚Äî volta ao comportamento original (permitindo letras e quebras de linha)
PAT = re.compile(
    r"(CPF|CNPJ|Multa)[^\d]{0,40}([\d\.\-\/,\s]{3,60})",
    flags=re.IGNORECASE | re.DOTALL
)

def normalize_id(term: str, raw_number: str) -> str:
    term_up = term.upper()

    digits = re.sub(r"\D", "", raw_number)
    if term_up == "CPF":
        m = re.search(r"\d{11}", digits)
        return m.group(0) if m else digits

    if term_up == "CNPJ":
        m = re.search(r"\d{14}", digits)
        return m.group(0) if m else digits

    # Multa (12.345,67 -> 12345.67)
    m = re.search(r"\d[\d\.\s]{0,15},\d{2}", raw_number) or re.search(r"\d[\d\.\s]{3,}", raw_number)
    if m:
        val = m.group(0)
        val = re.sub(r"\s", "", val).replace(".", "").replace(",", ".")
        return val
    return re.sub(r"[^\d,\.]", "", raw_number)

# ====== 4) Extrair DocuSign Envelope ID ======
full_text = "\n".join(df["conteudo"].tolist())
envelope_id = ""
m_env = DOCUSIGN_RE.search(full_text)
if m_env:
    g = GUID_RE.search(m_env.group(0))
    if g:
        envelope_id = g.group(0).upper()

# ====== 5) Extrair chaves e normalizar ======
matches_total = []
for _, row in df.iterrows():
    t = row["conteudo"]
    for m in PAT.finditer(t):
        term = m.group(1)
        raw_num = m.group(2)
        clean = normalize_id(term, raw_num)
        matches_total.append({
            "pagina": row["pagina"],
            "termo": term.upper(),
            "numero_encontrado": clean
        })

# ====== 6) Montar DataFrame final ======
doc_id = os.path.splitext(os.path.basename(pdf_path))[0]

rows = []
for m in matches_total:
    rows.append({
        "DOC_ID": doc_id,
        "DocuSign Envelope ID": envelope_id,
        "CHAVE": m["termo"],
        "CHAVE_ID": m["numero_encontrado"]
    })

out_df = pd.DataFrame(rows, columns=["DOC_ID", "DocuSign Envelope ID", "CHAVE", "CHAVE_ID"])

# ====== 7) Salvar em XLSX (substitui se j√° existir) ======
if os.path.exists(output_xlsx):
    os.remove(output_xlsx)

with pd.ExcelWriter(output_xlsx, engine="openpyxl") as writer:
    out_df.to_excel(writer, index=False, sheet_name="Resultado")

print(f"\n‚úÖ Arquivo salvo em: {output_xlsx}")
print(f"üìÑ Linhas: {len(out_df)} | ‚úâÔ∏è Envelope: {envelope_id or '‚Äî'}")
