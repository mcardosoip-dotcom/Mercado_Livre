import os
import random
from collections import Counter

import pandas as pd
import matplotlib.pyplot as plt

from openpyxl import load_workbook
from openpyxl.styles import PatternFill, Font, Alignment

# ===== Configuração de Diretório de Saída =====
output_dir     = r'C:\Users\mufranca\Desktop\Cartas'
os.makedirs(output_dir, exist_ok=True)
initial_path   = os.path.join(output_dir, 'cartas1_S3.xlsx')
formatted_path = os.path.join(output_dir, 'cartas1_formatado_S3.xlsx')
plot_path      = os.path.join(output_dir, 'plot_cartas_S3.png')

# ===== Parâmetros de Simulação =====
min_cards       = 8    # nível 1 começa em 8 cartas
max_cards       = 27   # nível 20 usa 26 cartas
hands_per_n     = 1000                       
multiplicadores = {
    "Royal Flush":      10,
    "Straight Flush":    9,
    "Four of a Kind":    8,
    "Full House":        7,
    "Flush":             6,
    "Straight":          5,
    "Three of a Kind":   4,
    "Two Pair":          3,
    "One Pair":          2,
    "High Card":         1
}

# ===== Helpers de Poker =====
def numero_carta(c):
    m = {'A':14,'K':13,'Q':12,'J':11}
    v = c[:-1]
    return int(v) if v.isdigit() else m[v]

def valor_carta(c):
    v = c[:-1]
    if v in ('J','Q','K'): return 10
    if v == 'A': return 11
    return int(v)

def get_best_sequence(vals):
    u = sorted(set(vals))
    if set([14,2,3,4,5]).issubset(u):
        return [14,2,3,4,5]
    for i in range(len(u)-4):
        w = u[i:i+5]
        if w == list(range(w[0], w[0]+5)):
            return w
    return []

def identificar_mao(mao):
    naipes     = [c[-1] for c in mao]
    cnt        = Counter(c[:-1] for c in mao)
    freq       = sorted(cnt.values(), reverse=True)
    nums       = [numero_carta(c) for c in mao]
    suit_cnt   = Counter(naipes)
    flush_suit = next((s for s,c in suit_cnt.items() if c >= 5), None)

    # Royal Flush
    if flush_suit:
        suited = [c for c in mao if c[-1]==flush_suit]
        s_nums = [numero_carta(c) for c in suited]
        if set([10,11,12,13,14]).issubset(s_nums):
            valid = [c for c in suited if numero_carta(c) in [10,11,12,13,14]]
            return "Royal Flush", valid

    # Straight Flush
    if flush_suit:
        suited = [c for c in mao if c[-1]==flush_suit]
        seq    = get_best_sequence([numero_carta(c) for c in suited])
        if seq:
            valid = [c for c in suited if numero_carta(c) in seq]
            return "Straight Flush", valid

    # Four of a Kind
    if 4 in freq:
        v4 = next(v for v,c in cnt.items() if c==4)
        valid = [c for c in mao if c[:-1]==v4]
        return "Four of a Kind", valid

    # Full House
    if 3 in freq and 2 in freq:
        trio = next(v for v,c in cnt.items() if c==3)
        pair = next(v for v,c in cnt.items() if c==2)
        valid = [c for c in mao if c[:-1] in (trio,pair)]
        return "Full House", valid

    # Flush
    if flush_suit:
        suited = [c for c in mao if c[-1]==flush_suit]
        valid = sorted(suited, key=numero_carta)[-5:]
        return "Flush", valid

    # Straight
    seq = get_best_sequence(nums)
    if seq:
        valid = [c for c in mao if numero_carta(c) in seq]
        return "Straight", valid

    # Three of a Kind
    if 3 in freq:
        v3 = next(v for v,c in cnt.items() if c==3)
        valid = [c for c in mao if c[:-1]==v3]
        return "Three of a Kind", valid

    # Two Pair
    if freq.count(2)>=2:
        pairs = [v for v,c in cnt.items() if c==2][:2]
        valid = [c for c in mao if c[:-1] in pairs]
        return "Two Pair", valid

    # One Pair
    if 2 in freq:
        vp = next(v for v,c in cnt.items() if c==2)
        valid = [c for c in mao if c[:-1]==vp]
        return "One Pair", valid

    # High Card
    hc = max(mao, key=numero_carta)
    return "High Card", [hc]

# ===== Simulação =====
results = []
deck = [f"{v}{s}" for v in (['A']+[str(i) for i in range(2,11)]+['J','Q','K']) 
        for s in ['♠','♥','♦','♣']]

for n in range(min_cards, max_cards+1):
    for _ in range(hands_per_n):
        mao = random.sample(deck, n)
        tipo, validas = identificar_mao(mao)
        pontos = sum(valor_carta(c) for c in validas) * multiplicadores[tipo]
        row = {
            'Quantidade': n,
            'TipoCompleto': tipo,
            'Pontuação': pontos
        }
        # inclua todas as cartas para validação
        for i in range(max_cards):
            row[f'Carta {i+1}'] = mao[i] if i < n else ''
        results.append(row)

df = pd.DataFrame(results)

# ===== Exporta e Formata Excel =====
df.to_excel(initial_path, index=False)
wb = load_workbook(initial_path)
ws = wb.active

fill_red   = PatternFill('solid', fgColor='8B0000')
fill_black = PatternFill('solid', fgColor='000000')
white      = Font(color='FFFFFF')
center     = Alignment('center','center')

cols_carta = [c.column for c in ws[1] if str(c.value).startswith('Carta')]
for row in ws.iter_rows(min_row=2):
    for col in cols_carta:
        cell = row[col-1]
        if not cell.value:
            cell.fill = PatternFill(); cell.font = Font()
        else:
            cell.fill = fill_red if cell.value[-1] in ('♥','♦') else fill_black
            cell.font = white
            cell.alignment = center
    row[0].alignment = center
    row[1].alignment = center

wb.save(formatted_path)

# ===== Plot Distribuições + Média =====
df_plot   = df[['Quantidade','TipoCompleto','Pontuação']]

# contagem empilhada por tipo
counts    = df_plot.groupby(['Quantidade','TipoCompleto']).size().unstack(fill_value=0)
order     = ["High Card","One Pair","Two Pair","Three of a Kind",
             "Straight","Flush","Full House","Four of a Kind",
             "Straight Flush","Royal Flush"]
counts    = counts.reindex(columns=order, fill_value=0)

# média de pontuação, garantindo 8–26 completos
levels    = list(range(min_cards, max_cards+1))
avg_score = df_plot.groupby('Quantidade')['Pontuação'].mean().reindex(levels)

fig, ax = plt.subplots(figsize=(10,6))
counts.plot(kind='bar', stacked=True, ax=ax, zorder=1)

ax.set_xlabel('Quantidade de Cartas')
ax.set_ylabel('Contagem de Mãos')
ax.set_xticks(range(len(levels)))
ax.set_xticklabels(levels)

# linha preta da média
ax2 = ax.twinx()
ax2.plot(range(len(levels)), avg_score.values,
         marker='o', color='black', zorder=2, label='Média de Pontos')
ax2.set_ylim(0, avg_score.max()*1.1)
ax2.set_ylabel('Média de Pontuação')
ax2.legend(loc='upper left')

plt.title('Distribuição de Mãos e Média de Pontuação (Sistema 3)')
plt.tight_layout()
plt.savefig(plot_path)
print(f'Gráfico salvo em {plot_path}')
plt.show()
